Has de respondre dins d'aquest mateix fitxer .txt, posant la teva resposta
sota de cada pregunta, excepte la pregunta 3) que la respondràs adjuntant la
b.d. sqlite3 amb les taules normalitzades. Aquest és un fitxer de text sense
format, edita'l només amb un editor de text pla.

Considerem que controlem els estudiants aprovats en les assignatures del grau
d'informàtica mitjançant una única relació, amb els següents atributs:

* Codi de l'estudiant
* Nom de l'estudiant
* Ciutat on viu l'estudiant
* Comarca on viu l'estudiant
* Puntuació que ha tret l'estudiant
* Data que ha aprovat
* Codi de l'assignatura
* Semestre de l'assignatura

Els estudiants es distingeixen pel seu codi, les ciutats i comarques pel seu nom
i les assignatures pel seu codi. La puntuació en que s'aprova una assignatura
pot ser inferior a 5, ja que la pot aprovar compensant-la (amb una nota entre
4 i 5).

Evidentment un estudiant no pot aprovar una assignatura dues vegades.

# cd Desktop/DABD/A1
# sqlite3 aprovats.db

1) Crea les queries que responguin les següents preguntes (una sola query per
cada pregunta). Has de distingir el fet que un alumne aprova una assignatura
(apareix en la relació) del fet que un alumne REALMENT aprova l'assignatura
(apareix en la relació amb una puntuació igual o major a 5).

1.a) Número d'estudiants de cada comarca
SELECT district, count(DISTINCT name) FROM aprovat GROUP BY district;
******************************************************************************************************************************
1.b) Els estudiants que tenen la nota més alta
# SELECT name,grade FROM aprovat ORDER BY grade DESC ;	//de mayor a menor
# SELECT name,grade FROM aprovat WHERE grade = 10;

SELECT name,grade FROM aprovat WHERE grade = (SELECT MAX(grade) FROM aprovat);

select code, name, avg(grade) from aprovat group by code order by avg(grade) desc limit 3;	//MEDIA MÁS ALTA
#asc; 		//de menor a mayor
#limit 10;	//si quieres los 10 con alta nota
******************************************************************************************************************************
1.c) Quants estudiants no tenen cap assignatura suspesa (nota inferior a 5)
# SELECT name FROM aprovat WHERE name NOT IN(SELECT name FROM aprovat WHERE grade < 5) GROUP BY name; //not in excluye
# SELECT COUNT(DISTINCT name) FROM aprovat WHERE name NOT IN(SELECT name FROM aprovat WHERE grade < 5);
******************************************************************************************************************************
1.d) Any en que hi ha més compensables (nota igual o superior a 4 i inferior a 5)

select strftime('%Y',pdate), count(grade) from aprovat where grade>=4 and grade<5 GROUP BY strftime('%Y',pdate) order by count(grade) desc limit 1;
#SELECT strftime('%Y',pdate), count(*) AS sem from aprovat WHERE grade >= 4 AND grade < 5 GROUP BY semester ORDER BY sem DESC LIMIT 1;

# SELECT semester, count(*) AS sem FROM aprovat WHERE grade >= 4 AND grade < 5 GROUP BY semester ORDER BY sem DESC LIMIT 1;
//AGRUPAR POR SEMESTRES Y ORDENAR POR SEMESTRES y poner como limit 1 des desc para coger el que mas hay compensaciones
//ponemos el alias a count para luego ordenar por el numero de compensacione y no por cuatrimestre
******************************************************************************************************************************
1.e) L'estudiant amb més nota de cada assignatura ordenades per quadrimestre i assignatura
# SELECT name, MAX(grade), subject, semester FROM aprovat GROUP BY subject ORDER BY semester;

******************************************************************************************************************************
1.f) Parelles d'estudiants diferents que tenen la mateixa nota en la mateixa assignatura
# SELECT a1.name, a2.name FROM aprovat a1, aprovat a2 WHERE a1.name < a2.name AND a1.grade == a2.grade AND a1.subject == a2.subject;
//a1.name, a2.name --> campos que se quiere imprimir
//aprovat a1, aprovat a2 --> coger dos tablas de la misma aprovat para ir comparando
//a1.name < a2.name --> que no tengan el mismo nombre
//a1.grade == a2.grade AND a1.subject == a2.subject --> que sean la misma asignatura y tengan la misma nota
----------------------------------------------------------------------------------------------------------------
2) Quines dependències funcionals (D.F.) té el problema? Usa els mateixos noms
d'atributs que els que apareixen a la taula.

code -> name, city
city -> district
subject -> semester
code, subject -> grade, pdate

estudiante : R1(code(P.K), name, city(F.K-R2))
ciudad : R2(city (P.K), district)
asignatura : R3(subject(P.K), semester)
aprobados : R4(code(F.K-R1), subject(F.K-R3), grade, pdate, PK(code, subject))

----------------------------------------------------------------------------------------------------------------

3) A partir de les D.F. anteriors, crea les taules adequades per tal que
estiguin normalitzades en 3FN. Recorda de definir les claus primàries,
alternatives i foranes, les polítiques ON DELETE i ON UPDATE de les claus
foranes i si els atributs són NOT NULL.

CREATE TABLE ciudad (city varchar(50) NOT NULL PRIMARY KEY, district varchar(50) NOT NULL);
CREATE TABLE asignatura (subject char(4) NOT NULL PRIMARY KEY, semester char(2) NOT NULL);
CREATE TABLE estudiante (code char(4) NOT NULL PRIMARY KEY, name varchar(50) NOT NULL, city varchar(50) NOT NULL, FOREIGN KEY (city) REFERENCES asignatura ON UPDATE CASCADE ON DELETE CASCADE);
CREATE TABLE aprobados(code char(4) NOT NULL, subject char(4) NOT NULL, grade decimal(3, 1) CHECK (grade >= 4 AND grade <= 10) NOT NULL, pdate date, PRIMARY KEY(code, subject), FOREIGN KEY(code) REFERENCES estudiante(code) ON UPDATE CASCADE ON DELETE CASCADE, FOREIGN KEY (subject) REFERENCES asignatura(subject) ON UPDATE CASCADE ON DELETE CASCADE);
----------------------------------------------------------------------------------------------------------------

4) Trasllada les dades de la taula original a les taules normalitzades.

INSERT INTO ciudad SELECT DISTINCT city,district FROM aprovat;		//Para que no hayan repetida hay que hacer en DISTINCT
INSERT INTO asignatura SELECT DISTINCT subject, semester FROM aprovat;
INSERT INTO estudiante SELECT DISTINCT code,name,city FROM aprovat;
INSERT INTO aprobados SELECT DISTINCT code,subject,grade,pdate FROM aprovat;

----------------------------------------------------------------------------------------------------------------

5) Resol les mateixes queries de l'apartat 1) sobre les taules normalitzades.
5.a) Número d'estudiants de cada comarca
>SELECT district, count(code) FROM (SELECT DISTINCT a1.district,a2.code FROM ciudad a1, estudiante a2 WHERE a1.city==a2.city) GROUP BY district;


5.b)Els estudiants que tenen la nota més alta
>SELECT name,grade FROM (SELECT a1.name, a2.grade FROM estudiante a1, aprobados a2 WHERE a1.code=a2.code) WHERE grad
e = (SELECT MAX(grade) FROM aprobados);

5.c)Quants estudiants no tenen cap assignatura suspesa (nota inferior a 5)
SELECT COUNT(DISTINCT code) FROM aprobados WHERE code NOT IN(SELECT code from aprobados WHERE grade < 5);

5.d)Any en que hi ha més compensables (nota igual o superior a 4 i inferior a 5)
SELECT strftime('%Y',pdate) AS any, COUNT(grade) FROM aprobados WHERE grade >=4 AND grade < 5 GROUP BY any ORDER BY grade DESC LIMIT 1;


5.e)L'estudiant amb més nota de cada assignatura ordenades per quadrimestre i assignatura
SELECT name, MAX(grade), subject, semester FROM (SELECT a1.name, a2.grade, a3.subject, a3.semester FROM estudiante a1, aprobados a2, asignatura a3 WHERE a1.code=a2.code AND a2.subject=a3.subject) GROUP BY subject ORDER BY semester;

5.f)Parelles d'estudiants diferents que tenen la mateixa nota en la mateixa assignatura
SELECT DISTINCT a1.code, a2.code, a1.grade, a1.subject FROM aprobados a1, aprobados a2 WHERE a1.code < a2.code AND a1.grade = a2.grade AND a1.subject=a2.subject;

----------------------------------------------------------------------------------------------------------------

6) La data en que s'han aprovat (inclou els compensables) les assignatures durant el 2019 es retarda 7 dies

6.a) Quina seria la query per resoldre aquest problema sobre la taula no
normalitzada?


6.b) I en les taules normalitzades?
update examens set pdate = DATE(pdate,'+7 day') where strftime('%Y',pdate) IN ('2019');